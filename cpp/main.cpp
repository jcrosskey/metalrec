/*
 * main.cpp
 *
 * Created on: Tue Nov 11 10:58:50 EST 2014
 * Author: JJ Chai
 */

/*** utility functions ***/
#include "Common.h"
/*** Read class ***/
#include "Read.h"
/*** Dataset class ***/
#include "Dataset.h"
/*** Edge class ***/
#include "Edge.h"
/*** HashTable class ***/
#include "HashTable.h"
/*** OverlapGraph class ***/
#include "OverlapGraph.h"
/* check file existence and permissions */
#include <unistd.h>
int loglevel; // logging level in integer format, for different levels of verbosity

void usage();
void parseArguments(int argc, char **argv, string & inputSamFile, string & PacBioFasta, string & allFileName, 
		UINT64 & minimumOverlapLength, UINT64 & hashStringLength, UINT32 & maxError, UINT32 & rubPos, 
		float & maxErrorRate, string & outputDir, string & outputFastaName, float & indelRate, float & subRate, 
		bool & useLikelihood, bool & scrub, string & blasr_path, string & scrub_path, string & pick_path);

/************************
 * Help usage
 * **********************/
void usage()
{
	std::cout << std::endl
		<< "  Usage:" << std::endl
		<< "    metalrec [OPTION]...<PARAM>..." << std::endl
		<< std::endl
		<< "  <PARAM>" << std::endl
		<< "    -s\tinputSamFile (default: stdin) " << std::endl  // Input sam file, generated by BLASR, with soft clipping
		<< "    -pf\tinput PacBio read fasta (default:  none) " << std::endl  // Input sam file, generated by BLASR, with soft clipping
		<< "    -l\tminimum overlap length (default: 40)" << std::endl  // minimum overlap length
		<< std::endl
		<< "  [OPTION]" << std::endl
		<< "    -h/--help" << std::endl
		<< "    -f\tOutput file name prefix (default: metalrec)" << std::endl    // all output file with have this name with different extensions.
		<< "    -od\tOutput directory (default: ./ current working directory)" << std::endl    // output directory
		<< "    -o\tFasta files full path name with corrected sequence (default: outputDir + inputSam.fasta)" << std::endl    // output directory
		<< "    -k\thash string length (kmer length, default: 10)" << std::endl  // hash string length
		<< "    -r\trubber length (default: 10)" << std::endl  // hash string length
		<< "    -e\tMaximum (substitution) errors allowed in the overlap (default: 0)" << std::endl    // Maximum (substitution) errors allowed in the overlap between Illumina reads
		<< "    -er\tMaximum (substitution) error rate allowed in the overlap (default: 0)" << std::endl    // Maximum (substitution) error rate allowed in the overlap
		<< "    -indelRate\tMaximum indel error rate allowed in the alignment to the PacBio read (default: 0.25)" << std::endl
		<< "    -subRate\tMaximum substitution error rate allowed in the alignment to the PacBio read (default: 0.05)" << std::endl
		<< "    -log\tSpecify log/output verbosity level, from ERROR, WARNING, INFO, DEBUG (default: INFO)" << std::endl 
		<< "    -pick\tAfter contigs are generated, align them to PacBio read with BLASR and pick a best contig (default: FALSE)" << std::endl 
		<< "    -scrub\tAfter contigs are generated, use the scrubbing module to IMPROVE the result (default: FALSE)" << std::endl 
		<< "    -blasr_path\tpath to BLASR executable (default: blasr)" << std::endl 
		<< "    -pick_path\tpath to contig-picking executable (default: pickContig)" << std::endl 
		<< "    -scrub_path\tpath to scrubbing executable (default: scrub.py)" << std::endl 
		<< std::endl;
}

/**********************************************************************************************************************
  Parse the input arguments
 **********************************************************************************************************************/
void parseArguments(int argc, char **argv, string & inputSamFile, string & PacBioFasta, string & allFileName, 
		UINT64 & minimumOverlapLength, UINT64 & hashStringLength, UINT32 & maxError, UINT32 & rubPos, 
		float & maxErrorRate, string & outputDir, string & outputFastaName, float & indelRate, float & subRate, 
		bool & useLikelihood, bool & scrub, string & blasr_path, string & scrub_path, string & pick_path)
{
	allFileName = "metalrec";
	minimumOverlapLength = 40;
	hashStringLength = 10;
	maxError = 0;
	maxErrorRate = 0.0;
	indelRate = 0.25;
	subRate = 0.05;
	rubPos = 10;
	inputSamFile = "";
	outputDir = "./";
	outputFastaName = "";
	blasr_path = "blasr";
	scrub_path = "scrub";
	pick_path = "pickContig";
	PacBioFasta = "";

	useLikelihood = false;
	scrub = false;
	FILELog::ReportingLevel();	// Initialize the log level to the default (INFO)
	vector<string> argumentsList;
	cout << endl;
	while(argc--)
		argumentsList.push_back(*argv++);

	if(argumentsList.size() == 1)
	{
		usage();
		exit(0);
	}

	for(UINT64 i = 1; i <= argumentsList.size()-1; i++)
	{
		if (argumentsList[i] == "-h" || argumentsList[i] == "--help")
		{
			usage();
			exit(0);
		}
		else if (argumentsList[i] == "-s")
			inputSamFile = argumentsList[++i];
		else if (argumentsList[i] == "-pf")
			PacBioFasta = argumentsList[++i];
		else if (argumentsList[i] == "-f")
			allFileName = argumentsList[++i];
		else if (argumentsList[i] == "-l")
			minimumOverlapLength = atoi(argumentsList[++i].c_str());
		else if (argumentsList[i] == "-k")
			hashStringLength = atoi(argumentsList[++i].c_str());
		else if (argumentsList[i] == "-e")
			maxError = atoi(argumentsList[++i].c_str());
		else if (argumentsList[i] == "-er")
			maxErrorRate = atof(argumentsList[++i].c_str());
		else if (argumentsList[i] == "-indelRate")
			indelRate = atof(argumentsList[++i].c_str());
		else if (argumentsList[i] == "-subRate")
			subRate = atof(argumentsList[++i].c_str());
		else if (argumentsList[i] == "-r")
			rubPos = atoi(argumentsList[++i].c_str());
		else if (argumentsList[i] == "-od")
			outputDir = argumentsList[++i];
		else if (argumentsList[i] == "-o")
			outputFastaName = argumentsList[++i];
		else if (argumentsList[i] == "-pick")
			useLikelihood = !useLikelihood;
		else if (argumentsList[i] == "-scrub")
			scrub = !scrub;
		else if (argumentsList[i] == "-blasr_path")
			blasr_path = argumentsList[++i];
		else if (argumentsList[i] == "-pick_path")
			pick_path = argumentsList[++i];
		else if (argumentsList[i] == "-scrub_path")
			scrub_path = argumentsList[++i];
		else if (argumentsList[i] == "-log"){
			try{
				FILELog::ReportingLevel() = FILELog::FromString(argumentsList[++i]);
			}
			catch(const std::exception& e)
			{
				FILE_LOG(logERROR) << e.what();
				FILELog::FromString("INFO");
			}
		}
		else
		{
			usage();                /* TODO should we ignore unrecognizable options or just quit...? */
			exit(0);
		}
	}

	if(minimumOverlapLength == 0)
	{
		FILE_LOG(logERROR) << "missed -l option!" << std::endl;
		usage();
		exit(0);
	}

	if ( hashStringLength >= minimumOverlapLength ) {
		FILE_LOG(logWARNING) << "hash string length is greater than the minimum overlap length, reset to minOverlap - 1" << std::endl;
		hashStringLength = minimumOverlapLength - 1;
	}
	if(maxErrorRate < 0 || maxErrorRate > 1)
	{
		FILE_LOG(logERROR) << "maximum error rate has to be between 0 and 1!" << std::endl;
		usage();
		exit(0);
	}

	if(inputSamFile.size() == 0)
	{
		FILE_LOG(logWARNING) << "missed input sam file, use stdin as input" << std::endl;
	}
	Utils::mkdirIfNonExist(outputDir);
	if (outputFastaName.size() == 0)
		outputFastaName = outputDir + "/" + Utils::getFilename(inputSamFile) + ".fasta";
	if (useLikelihood && scrub)             /* When both likelihood-picking and scrubbing are chosen, use scrubbing instead */
	{
		FILE_LOG(logWARNING) << "Cannot use likelihood-picking and scrubbing simutaneously, use scrubbing instead";
		useLikelihood = false;
	}
	if ( (useLikelihood || scrub) && access(blasr_path.c_str(), X_OK) == -1) /* blasr does not have execute permission */
	{
		FILE_LOG(logWARNING) << "BLASR " << blasr_path << " is not executable, running with no post-processing";
		useLikelihood = false;
		scrub = false;
	}
	if ( scrub && access(scrub_path.c_str(), X_OK) == -1) /* scrub does not have execute permission */
	{
		FILE_LOG(logWARNING) << "scrub program " << scrub_path << " is not executable, running with no scrubbing";
		scrub = false;
	}
	if ( useLikelihood && access(pick_path.c_str(), X_OK) == -1) /* scrub does not have execute permission */
	{
		FILE_LOG(logWARNING) << "contig-picking program " << pick_path << " is not executable, running with no scrubbing";
		scrub = false;
	}
	if ( (useLikelihood || scrub) && PacBioFasta.length() == 0) /* PacBio fasta file is not provided */
	{
		FILE_LOG(logWARNING) << "fasta file including PacBio fasta file is not available, running without post-processing";
		scrub = false;
		useLikelihood = false;
	}

	FILE_LOG(logDEBUG) << "input sam file: " << inputSamFile;
	FILE_LOG(logDEBUG) << "output file name prefix: " << allFileName;
	FILE_LOG(logDEBUG) << "minimum overlap length: " << minimumOverlapLength;
	FILE_LOG(logDEBUG) << "hash string length: " << hashStringLength;
	FILE_LOG(logDEBUG) << "maximum error allowed in the overlap: " << maxError;
	FILE_LOG(logDEBUG) << "maximum error rate allowed in the overlap: " << maxErrorRate;
	FILE_LOG(logDEBUG) << "maximum indel error rate allowed in the alignment: " << indelRate;
	FILE_LOG(logDEBUG) << "maximum substitution error rate allowed in the alignment: " << subRate;
	FILE_LOG(logDEBUG) << "rubber length: " << rubPos;
	FILE_LOG(logDEBUG) << "using likelihood to pick contigs: " << (useLikelihood ? "true" : "false");
	FILE_LOG(logDEBUG) << "use scrubbing for post processing: " << (scrub ? "true" : "false");
}

/************************
 * main function
 * **********************/
int main(int argc, char **argv)
{
	CLOCKSTART;
	/* Declare variables to be used later */
	string inputSamFile, allFileName, outputDir, outputFastaName, blasr_path, scrub_path, pick_path, PacBioFasta;
	UINT64 minimumOverlapLength, hashStringLength;
	UINT32 rubberPos, maxError;
	float maxErrorRate, indelRate, subRate;
	bool useLikelihood, scrub;
	/** Parse command line arguments **/
	parseArguments(argc, argv, inputSamFile, PacBioFasta, allFileName, minimumOverlapLength, hashStringLength, maxError, rubberPos, maxErrorRate, outputDir, outputFastaName,indelRate,subRate, useLikelihood, scrub, blasr_path, scrub_path, pick_path);
	loglevel = FILELog::ReportingLevel(); // logging level in integer
	FILE_LOG(logDEBUG1) << "Parsing argument list finished";
	//cout << "logging level is " << loglevel << endl;	// For debugging only

	/** Read sam file and store all the reads **/
	Dataset * dataSet;
	if (inputSamFile.length() > 0)
		dataSet = new Dataset(inputSamFile, minimumOverlapLength, indelRate, subRate);	// reads the .sam file
	else
		dataSet = new Dataset(stdin, minimumOverlapLength, indelRate, subRate);	// read from the stdin stream, (should add guardlock for lines that are not part of sam file but in the std input stream
	FILE_LOG(logINFO) << "Length of the PacBio read is " << dataSet->getPacBioReadLength(); /* print PacBio read length */
	if (dataSet->getNumberOfReads() <= 1)
		FILE_LOG(logERROR) << "Data set " << inputSamFile << " has no more than 1 read in it, quitting...";

	else /* If the dataset has some reads in it, build hash table and overlap graph next */
	{
		FILE_LOG(logINFO) << "number of unique reads in dataset is " << dataSet->getNumberOfUniqueReads();
		HashTable *ht = new HashTable();
		ht->insertDataset(dataSet, hashStringLength);
		OverlapGraph *graph = new OverlapGraph(ht, minimumOverlapLength, maxError, maxErrorRate, rubberPos);
		delete ht;                      /* delete hash table after overlap graph is built */
		if (graph->getNumberOfEdges() == 0)
			FILE_LOG(logERROR) << "Data set " << inputSamFile << " has no edge in it, quitting...";

		else /* If there is at least 1 edge in the data set, try to calculate flow and output contigs */
		{
			graph->calculateFlow();
			FILE_LOG(logINFO) << "nodes: " << graph->getNumberOfNodes() << " edges: " << graph->getNumberOfEdges() << endl;
			graph->removeAllSimpleEdgesWithoutFlow();
			graph->simplifyGraph();
			vector<Edge *> contigEdges;
			graph->getEdges(contigEdges);
			if (loglevel > 3)
				graph->printGraph(outputDir + "/" + allFileName+"_graph.gdl", contigEdges);
			if (contigEdges.size() > 1) /* More than 1 contigs resulted, depend on the post-processing options, do different things */
			{
				if (!useLikelihood && !scrub) /* Neither using likelihood nor scrubbing, just print the longest contig */
					graph->printContigs(outputFastaName, contigEdges,true);
				else
				{
					FILE_LOG(logDEBUG) << "Start post-processing";
					string tmpFastaFile = outputDir + "/" +  allFileName + "_tmp.contigs.fasta";
//					if (mkstemp(tmpFastaFile)==-1)
//					{
//						perror("Encounter error in mkstemp");
//						Utils::exitWithError("Error");
//					}
					FILE_LOG(logDEBUG3) << "Generating temporary fasta file: " << tmpFastaFile;
					//tmpFastaFile = tmpnam(NULL); /* Generate a temporary file name different from the name of any existing file */
					graph->printContigs(tmpFastaFile, contigEdges,false); /* Save the contigs in this temporary fasta file */

					int res;
					/* Use BLASR to align the contigs to the PacBio read */
					if (useLikelihood)
					{
						string tmp_samFile = outputDir + "/" +  allFileName + "_tmp.contigs.sam";
						string blasr_cmd = blasr_path + " " + tmpFastaFile + " " + PacBioFasta + " -noSplitSubreads -sam -clipping soft -out " + tmp_samFile + " 2> /dev/null";
						//FILE_LOG(logINFO) << "running blasr_cmd " << blasr_cmd;
						res = system(blasr_cmd.c_str());
						if(res != 0){
							FILE_LOG(logERROR) << "   *** Failed BLASR alignment to generate sam file";
						}
						else
						{
							string pick_cmd = pick_path + " -log ERROR -o " + outputFastaName + " -s " + tmp_samFile;
							res = system(pick_cmd.c_str());
							if(res != 0){
								FILE_LOG(logERROR) << "   *** Failed likelihood based contig picking";
							}
						}
						if (loglevel < 3){
							remove(tmpFastaFile.c_str());
							remove(tmp_samFile.c_str());
						}

					}
					else if (scrub)
					{

						string tmp_m5File = outputDir + "/" +  allFileName + "_tmp.contigs.m5";
						FILE_LOG(logDEBUG3) << "Generating temporary .m5 file: " << tmp_m5File;
						string blasr_cmd = blasr_path + " " + tmpFastaFile + " " + PacBioFasta + " -noSplitSubreads -m 5 -out " + tmp_m5File + " 2> /dev/null"; /* scrub module currently doesn't take stream input, so need to write the m5 file */
						res = system(blasr_cmd.c_str());
						if(res != 0){
							FILE_LOG(logERROR) << "   *** Failed BLASR alignment to generate m5 file";
						}
						else
						{
							string scrub_cmd = "python " + scrub_path + " -i " + PacBioFasta + " -s " + tmp_m5File + " -o " + outputFastaName + " &> /dev/null"; /* scrubbing */
							res = system(scrub_cmd.c_str());
							if(res != 0){
								cout << "   *** Failed scrubbing";
							}
						}
						if (loglevel < 3){
							remove(tmpFastaFile.c_str());
							remove(tmp_m5File.c_str());
						}
							
					}

				}
			}
			else                    /* Only 1 contig, or none, print the contig, and quit */
				graph->printContigs(outputFastaName, contigEdges,true);

		}
		delete graph;
	}

	delete dataSet;
	/*** For debugging, print the read containing information and the overlap information ***/
	//dataSet->printReadsTiling(allFileName + "_reads.tiling");

	CLOCKSTOP;
}
