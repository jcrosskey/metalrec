/*
 * Reads.h
 *
 * Created on: Fri Nov  7 11:51:37 EST 2014
 * Author: JJ Chai
 */


#ifndef READ_H_
#define READ_H_

#include "Common.h"
#include <seqan/sequence.h>
#include <seqan/basic.h>
#include <seqan/file.h>
#include <seqan/modifier.h>
#include <seqan/stream.h>
#include <seqan/bam_io.h>

class Edge;

// TODO: Add paired end reads support, add mate as a variable for read so that later paired end reads can be used.
// Add contained_reads as a variable for a read, to store the information of the reads contained in this read. Maybe the superReadID is enough??

/**********************************************************************************************************************
	Class to store a read.
**********************************************************************************************************************/
class Read
{
	private:
		UINT64 ID;	// Unique Identification of the read.
		seqan::CharString readName;	// Query/Read name (original name in the input file)
		seqan::DnaString readDnaString;	// Same as below, but with seqAn's String<Dna> implementation
		seqan::DnaString readReverseDnaString;	// Reverse complement string of the read ( need for bidirectional graph, might not be needed in this application )
		string cigarString;	// Cigar string, might be useful in the future. 
		UINT32 frequency;	// Frequency of the read. Number of times this read is present in the dataset. Used in some statistical analysis.
		UINT32 rStart;	// Alignment start position on the PacBio read
		//UINT32 rEnd;	// Alignment end position on the PacBio read
		UINT32 leftClip;	// Clipped length at the left end
		UINT32 rightClip;	// Clipped length at the right end
		UINT8 mapQV;	// Mapping quality value, smaller the better, 255 means quality is not available
		bool isReverseComplement;	// Is SEQ reverse complemented
		INT32 alignScore;	// Alignment Score generated by BLASR, negative value (smaller score means better alignment)
		INT32 startCoord;	// Coordinate of the first bp in the read

		/* Only the forward edges will be considered later on, but the bidirectional graph structure is kept (for now) */
		vector<Edge *> *listOfEdgesForward;   	// List of edges that contain the forward string of this read.
		vector<UINT64> *locationOnEdgesForward;	// List of locations on the edges that contain the forward string of the current read.
		vector<UINT64> *containedReadIDs;	// Pointer to vector of IDs of reads contained in this read
		vector<UINT64> *overlapReadIDs;	// Pointer to vector of IDs of reads overlapping with this read
		vector<UINT64> *overlapReadOffsets;	// Pointer to vector of offsets for the corresponding overlapping reads
		bool setClip(const string & s);
		INT32 getTag(const string & tagName, const string & alignRecord);

	public:
		Read(void);	// Default constructor.
		Read(const string & s);	// Another constructor, from alignment record in string format.
		Read(const seqan::BamAlignmentRecord & record);	// Another constructor, from BamAlignmentRecord
		~Read(void);	// Destructor.

		UINT64 superReadID;	// ID of the (longest) read containing this read. 
					// 0 = not a contained read, otherwise superReadID contains the ID of the uniqe super read.

		/* mutators */
		bool setRead(const string & s); 		// Set the read from alignment record string, (with generic string parsing)
		bool setRead(const seqan::BamAlignmentRecord & record); 		// Set the read from alignment record string, (with seqAn BamStream class)
		bool setReadID(UINT64 id); 			// Set the read ID.
		bool setFrequency(UINT32 freq);	// Set the ferquency of the read.
		bool setStartCoord(INT32 start_coord){startCoord = start_coord; return true;}	// Set the starting coordinate

		/* accessors */
		bool isContainedRead(void){return (superReadID == 0 ? false : true);};	// Whether the read is contained in another read
		seqan::DnaString getDnaStringForward(void){return readDnaString;}	// Get the forward string of the current read.
		seqan::DnaString getDnaStringReverse(void){return readReverseDnaString;}	// Get the forward string of the current read.
		seqan::CharString getReadName(void){return readName;}	// Get the name of the current read.
		INT32 getStartCoord(void){return startCoord;}	// Get the starting coordinate of the read, with clipped part added back
		INT32 getEndCoord(void);	// Get the ending coordinate of the read
		UINT32 getrStart(void) {return rStart;}	// Get the leftmost alignment position on the reference sequence.
		size_t getReadLength(void){return length(readDnaString);}	// Get the length of the string in the current read.
		UINT64 getID(void) {return ID;}	// Get the read number of the current read.
		UINT32 getFrequency(void) {return frequency;}	// Get the frequency of the current read.
		INT32 getAlignScore(void) {return alignScore;}	// Get the alignment score
		INT32 getMapQV(void) {return mapQV;}	// Get the mapping quality value
		bool isReverseComplemented(void) {return isReverseComplement;}	// Get the reverse complement status

		vector<Edge *> * getListOfEdgesForward(void){return listOfEdgesForward;}	// Get the list of edges that contain the forward string of the current read.
		vector<UINT64> * getLocationOnEdgesForward(void){return locationOnEdgesForward;}	// Get the list of locations on the edges that contain the forward string of the current read.
		vector<UINT64> * getContainedReadIDs(void){return containedReadIDs;}	// Get list of IDs of reads contained in this read.
		vector<UINT64> * getOverlapReadIDs(void){return overlapReadIDs;}	// Get list of IDs of reads overlapping with this read.
		vector<UINT64> * getOverlapReadOffsets(void){return overlapReadOffsets;}	// Get list of offsets for the corresponding overlapping reads.
};

#endif /* READS_H_ */
